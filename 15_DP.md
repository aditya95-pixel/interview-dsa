### 1. Longest Increasing Subsequence
Given an array arr[] of non-negative integers, the task is to find the length of the Longest Strictly Increasing Subsequence (LIS).

A subsequence is strictly increasing if each element in the subsequence is strictly less than the next element.

```cpp
class Solution {
  public:
    int lis(vector<int>& arr) {
        vector<int>dp(arr.size(),1);
        for(int i=0;i<arr.size();i++){
            for(int j=0;j<i;j++){
                if(arr[i]>arr[j] && dp[i]<dp[j]+1)
                dp[i]=dp[j]+1;
            }
        }
        return *max_element(dp.begin(),dp.end());
    }
};
```

### 2. Longest String Chain
You are given an array of words where each word consists of lowercase English letters.
wordA is a predecessor of wordB if and only if we can insert exactly one letter anywhere in wordA without changing the order of the other characters to make it equal to wordB. For example, "abc" is a predecessor of "abac", while "cba" is not a predecessor of "bcad".

A word chain is a sequence of words [word1, word2, ..., wordk] with k >= 1, where word1 is a predecessor of word2, word2 is a predecessor of word3, and so on. A single word is trivially a word chain with k = 1.

Return the length of the longest possible word chain with words chosen from the given list of words in any order.

```cpp
class Solution {
  public:
    bool isPred(const string&a,const string&b){
        if(a.size()!=b.size()+1)
        return false;
        int i=0,j=0;
        while(i<a.size() && j<b.size()){
            if(a[i]==b[j])
            {
                i++;
                j++;
            }
            else
            i++;
        }
        return (j==b.size());
    }
    static bool compare(const string&a,const string&b){
        return a.size()<b.size();
    }
    int longestStringChain(vector<string>& words) {
        sort(words.begin(),words.end(),compare);
        vector<int>dp(words.size(),1);
        for(int i=0;i<words.size();i++){
            for(int j=0;j<i;j++){
                if(isPred(words[i],words[j]))
                    dp[i]=max(dp[i],dp[j]+1);
            }
        }
        return *max_element(dp.begin(),dp.end());
    }
};
```

### 3. Longest Common Subsequence
Given two strings s1 and s2, return the length of their longest common subsequence (LCS). If there is no common subsequence, return 0.

A subsequence is a sequence that can be derived from the given string by deleting some or no elements without changing the order of the remaining elements. For example, "ABE" is a subsequence of "ABCDE".

```cpp
class Solution {
  public:
    int lcs(string &s1, string &s2) {
        vector<vector<int>>dp(s1.size()+1,vector<int>(s2.size()+1,0));
        for(int i=1;i<=s1.size();i++){
            for(int j=1;j<=s2.size();j++){
                if(s1[i-1]==s2[j-1])
                    dp[i][j]=1+dp[i-1][j-1];
                else if(s1[i-1]!=s2[j-1])
                    dp[i][j]=max(dp[i-1][j],dp[i][j-1]);
            }
        }
        return dp[s1.size()][s2.size()];
    }
};
```

### 4. Longest Palindromic Subsequence
Given a string s, return the length of the longest palindromic subsequence.

A subsequence is a sequence that can be derived from the given sequence by deleting some or no elements without changing the order of the remaining elements.

A palindromic sequence is a sequence that reads the same forward and backward.

```cpp
class Solution {
  public:
    int longestPalinSubseq(string &s) {
        vector<vector<int>>dp(s.size(),vector<int>(s.size(),1));
        for(int i=s.size()-1;i>=0;i--){
            for(int j=i;j<s.size();j++){
                if(i==j)
                continue;
                if(s[i]==s[j]){
                    if(i+1==j)
                        dp[i][j]=2;
                    else
                        dp[i][j]=dp[i+1][j-1]+2;
                }
                else
                    dp[i][j]=max(dp[i+1][j],dp[i][j-1]);
            }
        }
        return dp[0][s.size()-1];
    }
};
```

### 5. Longest Palindrome in a String
Given a string s, your task is to find the longest palindromic substring within s.

A substring is a contiguous sequence of characters within a string, defined as s[i...j] where 0 ≤ i ≤ j < len(s).

A palindrome is a string that reads the same forward and backward. More formally, s is a palindrome if reverse(s) == s.

Note: If there are multiple palindromic substrings with the same length, return the first occurrence of the longest palindromic substring from left to right.

```cpp
class Solution {
  public:
    string longestPalindrome(string &s) {
        vector<vector<bool>>dp(s.size(),vector<bool>(s.size(),0));
        for(int i=0;i<s.size();i++)
        dp[i][i]=true;
        int maxLen=1,start=0;
        for(int i=0;i<s.size()-1;i++){
            if(s[i]==s[i+1])
            {
                dp[i][i+1]=true;
                if(maxLen<2){
                    maxLen=2;
                    start=i;
                }
            }
        }
        for(int k=3;k<=s.size();k++){
            for(int i=0;i<s.size()-k+1;i++){
                int j=i+k-1;
                if(dp[i+1][j-1] && s[i]==s[j]){
                    dp[i][j]=true;
                    if(maxLen<k){
                        maxLen=k;
                        start=i;
                    }
                }
            }
        }
        return s.substr(start,maxLen);
    }
};
```

### 6. Palindrome SubStrings
Given a string s, count all palindromic sub-strings present in the string. The length of the palindromic sub-string must be greater than or equal to 2. 

```cpp
class Solution {
  public:
    int countPS(string &s) {
        int cnt=0;
        vector<vector<bool>>dp(s.size(),vector<bool>(s.size(),false));
        for(int i=0;i<s.size();i++)
        dp[i][i]=true;
        for(int i=0;i<s.size()-1;i++){
            if(s[i]==s[i+1])
            {
                dp[i][i+1]=true;
                cnt++;
            }
        }
        for(int k=3;k<=s.size();k++){
            for(int i=0;i<s.size()-k+1;i++){
                int j=i+k-1;
                if(dp[i+1][j-1] && s[i]==s[j])
                {
                    dp[i][j]=true;
                    cnt++;
                }
            }
        }
        return cnt;
    }
};
```
