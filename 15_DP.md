### 1. Longest Increasing Subsequence
Given an array arr[] of non-negative integers, the task is to find the length of the Longest Strictly Increasing Subsequence (LIS).

A subsequence is strictly increasing if each element in the subsequence is strictly less than the next element.

```cpp
class Solution {
  public:
    int lis(vector<int>& arr) {
        vector<int>dp(arr.size(),1);
        for(int i=0;i<arr.size();i++){
            for(int j=0;j<i;j++){
                if(arr[i]>arr[j] && dp[i]<dp[j]+1)
                dp[i]=dp[j]+1;
            }
        }
        return *max_element(dp.begin(),dp.end());
    }
};
```

### 2. Longest String Chain
You are given an array of words where each word consists of lowercase English letters.
wordA is a predecessor of wordB if and only if we can insert exactly one letter anywhere in wordA without changing the order of the other characters to make it equal to wordB. For example, "abc" is a predecessor of "abac", while "cba" is not a predecessor of "bcad".

A word chain is a sequence of words [word1, word2, ..., wordk] with k >= 1, where word1 is a predecessor of word2, word2 is a predecessor of word3, and so on. A single word is trivially a word chain with k = 1.

Return the length of the longest possible word chain with words chosen from the given list of words in any order.

```cpp
class Solution {
  public:
    bool isPred(const string&a,const string&b){
        if(a.size()!=b.size()+1)
        return false;
        int i=0,j=0;
        while(i<a.size() && j<b.size()){
            if(a[i]==b[j])
            {
                i++;
                j++;
            }
            else
            i++;
        }
        return (j==b.size());
    }
    static bool compare(const string&a,const string&b){
        return a.size()<b.size();
    }
    int longestStringChain(vector<string>& words) {
        sort(words.begin(),words.end(),compare);
        vector<int>dp(words.size(),1);
        for(int i=0;i<words.size();i++){
            for(int j=0;j<i;j++){
                if(isPred(words[i],words[j]))
                    dp[i]=max(dp[i],dp[j]+1);
            }
        }
        return *max_element(dp.begin(),dp.end());
    }
};
```

### 3. Longest Common Subsequence
Given two strings s1 and s2, return the length of their longest common subsequence (LCS). If there is no common subsequence, return 0.

A subsequence is a sequence that can be derived from the given string by deleting some or no elements without changing the order of the remaining elements. For example, "ABE" is a subsequence of "ABCDE".

```cpp
class Solution {
  public:
    int lcs(string &s1, string &s2) {
        vector<vector<int>>dp(s1.size()+1,vector<int>(s2.size()+1,0));
        for(int i=1;i<=s1.size();i++){
            for(int j=1;j<=s2.size();j++){
                if(s1[i-1]==s2[j-1])
                    dp[i][j]=1+dp[i-1][j-1];
                else if(s1[i-1]!=s2[j-1])
                    dp[i][j]=max(dp[i-1][j],dp[i][j-1]);
            }
        }
        return dp[s1.size()][s2.size()];
    }
};
```

### 4. Longest Palindromic Subsequence
Given a string s, return the length of the longest palindromic subsequence.

A subsequence is a sequence that can be derived from the given sequence by deleting some or no elements without changing the order of the remaining elements.

A palindromic sequence is a sequence that reads the same forward and backward.

```cpp
class Solution {
  public:
    int longestPalinSubseq(string &s) {
        vector<vector<int>>dp(s.size(),vector<int>(s.size(),1));
        for(int i=s.size()-1;i>=0;i--){
            for(int j=i;j<s.size();j++){
                if(i==j)
                continue;
                if(s[i]==s[j]){
                    if(i+1==j)
                        dp[i][j]=2;
                    else
                        dp[i][j]=dp[i+1][j-1]+2;
                }
                else
                    dp[i][j]=max(dp[i+1][j],dp[i][j-1]);
            }
        }
        return dp[0][s.size()-1];
    }
};
```

### 5. Longest Palindrome in a String
Given a string s, your task is to find the longest palindromic substring within s.

A substring is a contiguous sequence of characters within a string, defined as s[i...j] where 0 ≤ i ≤ j < len(s).

A palindrome is a string that reads the same forward and backward. More formally, s is a palindrome if reverse(s) == s.

Note: If there are multiple palindromic substrings with the same length, return the first occurrence of the longest palindromic substring from left to right.

```cpp
class Solution {
  public:
    string longestPalindrome(string &s) {
        vector<vector<bool>>dp(s.size(),vector<bool>(s.size(),0));
        for(int i=0;i<s.size();i++)
        dp[i][i]=true;
        int maxLen=1,start=0;
        for(int i=0;i<s.size()-1;i++){
            if(s[i]==s[i+1])
            {
                dp[i][i+1]=true;
                if(maxLen<2){
                    maxLen=2;
                    start=i;
                }
            }
        }
        for(int k=3;k<=s.size();k++){
            for(int i=0;i<s.size()-k+1;i++){
                int j=i+k-1;
                if(dp[i+1][j-1] && s[i]==s[j]){
                    dp[i][j]=true;
                    if(maxLen<k){
                        maxLen=k;
                        start=i;
                    }
                }
            }
        }
        return s.substr(start,maxLen);
    }
};
```

### 6. Palindrome SubStrings
Given a string s, count all palindromic sub-strings present in the string. The length of the palindromic sub-string must be greater than or equal to 2. 

```cpp
class Solution {
  public:
    int countPS(string &s) {
        int cnt=0;
        vector<vector<bool>>dp(s.size(),vector<bool>(s.size(),false));
        for(int i=0;i<s.size();i++)
        dp[i][i]=true;
        for(int i=0;i<s.size()-1;i++){
            if(s[i]==s[i+1])
            {
                dp[i][i+1]=true;
                cnt++;
            }
        }
        for(int k=3;k<=s.size();k++){
            for(int i=0;i<s.size()-k+1;i++){
                int j=i+k-1;
                if(dp[i+1][j-1] && s[i]==s[j])
                {
                    dp[i][j]=true;
                    cnt++;
                }
            }
        }
        return cnt;
    }
};
```

### 7. Edit Distance
Given two strings s1 and s2. Return the minimum number of operations required to convert s1 to s2.
The possible operations are permitted:

Insert a character at any position of the string.
Remove any character from the string.
Replace any character from the string with any other character.

```cpp
class Solution {
  public:
    // Function to compute the edit distance between two strings
    int editDistance(string& s1, string& s2) {
        vector<vector<int>>dp(s1.size()+1,vector<int>(s2.size()+1,0));
        for(int i=0;i<=s1.size();i++)
        dp[i][0]=i;
        for(int j=0;j<=s2.size();j++)
        dp[0][j]=j;
        for(int i=1;i<=s1.size();i++){
            for(int j=1;j<=s2.size();j++){
                if(s1[i-1]==s2[j-1])
                dp[i][j]=dp[i-1][j-1];
                else
                dp[i][j]=min({dp[i-1][j],dp[i][j-1],dp[i-1][j-1]})+1;
            }
        }
        return dp[s1.size()][s2.size()];
    }
};
```

### 8. Ways to Reach the n'th Stair
There are n stairs, a person standing at the bottom wants to reach the top. The person can climb either 1 stair or 2 stairs at a time. Your task is to count the number of ways, the person can reach the top (order does matter).

```cpp
class Solution {
  public:
    int countWays(int n) {
        vector<int>dp(n+1,0);
        dp[0]=1;
        dp[1]=1;
        for(int i=2;i<=n;i++)
        dp[i]=dp[i-1]+dp[i-2];
        return dp[n];
    }
};
```

### 9. Min Cost Climbing Stairs
Given an array of integers cost[] where cost[i] is the cost of the ith step on a staircase. Once the cost is paid, you can either climb one or two steps. Return the minimum cost to reach the top of the floor.
Assume 0-based Indexing. You can either start from the step with index 0, or the step with index 1.

```cpp
class Solution {
  public:
    int minCostClimbingStairs(vector<int>& cost) {
        vector<int>dp(cost.size()+1,0);
        for(int i=2;i<=cost.size();i++)
            dp[i]=min(dp[i-1]+cost[i-1],dp[i-2]+cost[i-2]);
        return dp[cost.size()];
    }
};
```
